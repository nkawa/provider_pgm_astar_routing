package main

import (
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"sync"

	"github.com/golang/protobuf/proto"

	_ "github.com/jbuchbinder/gopnm" // for reading pnm files
	sxcav "github.com/synerex/proto_cav"
	sxapi "github.com/synerex/synerex_api"
	sxproto "github.com/synerex/synerex_proto"
	sxutil "github.com/synerex/synerex_sxutil"

	astar "github.com/nkawa/astar_golang"
)

// feature info for PGM file.(generated by geojson_tool)
type Feature struct {
	MinLon, MinLat, MaxLon, MaxLat float64
	DLon, DLat                     float64
	Count                          int
	Scale                          float64
	PGMFile                        string
	PGMWidth, PGMHeight            int
	//	GeoJsonFC                      *geojson.FeatureCollection `json:"-"`
}

var (
	nodesrv         = flag.String("nodesrv", "127.0.0.1:9990", "node serv address")
	localsx         = flag.String("local", "", "Local Synerex Server")
	jsonfile        = flag.String("file", "higashi.json", "Feature Json File")
	robotid         = flag.Int("robot", 0, "Robot ID")
	sxServerAddress string
	sxClient        *sxutil.SXServiceClient
	feature         *Feature
	aStar           *astar.Astar
)

func loadFeature(fname string) *Feature {
	f := &Feature{}
	fp, err := os.Open(fname)
	if err != nil {
		log.Fatal("Can't open Feature file %s", fname)
	}
	defer fp.Close()
	buf, _ := ioutil.ReadAll(fp)

	err = json.Unmarshal(buf, f)
	if err != nil {
		log.Fatal("Error", err)
	}
	return f
}

func findRoute(x0, y0, x1, y1 float64) [][2]float64 {
	route, err := aStar.Plan(x0, y0, x1, y1)
	if err != nil {
		fmt.Print(err, "\n")
	} else {
		fmt.Print("route length:", len(route), "\n")
		//response!
	}
	return route
}

func publishPath(d *sxcav.Path) {
	out, err := proto.Marshal(d)
	if err != nil {
		log.Print(err)
	}
	cout := sxapi.Content{Entity: out}
	smo := sxutil.SupplyOpts{
		Name:  "SupplyRoute",
		Cdata: &cout,
	}
	_, err = sxClient.NotifySupply(&smo) // may by propose supply..
	if err != nil {
		log.Print(err)
	} else {
		log.Printf("publish path robot%d", d.RobotId)
	}
}

func demandCallback(clt *sxutil.SXServiceClient, dm *sxapi.Demand) {
	log.Printf("Got demand %#v", dm)
	if dm.GetDemandName() == "RouteDemand" {
		pr := &sxcav.PathRequest{}
		err := proto.Unmarshal(dm.Cdata.Entity, pr)
		if err != nil {
			log.Printf("Can't unmarshal data %v", err)
		}
		// routing point comes with X, Y
		route := findRoute(float64(pr.Start.X), float64(pr.Start.Y), float64(pr.Goal.X), float64(pr.Goal.Y))
		// convert route into Path
		if len(route) > 0 {
			path := &sxcav.Path{}
			path.Path = make([]*sxcav.PathPoint, len(route))
			path.RobotId = int64(*robotid)
			for i := 0; i < len(route); i++ {
				pP := new(sxcav.PathPoint)
				pP.Seq = int64(i)
				pP.Pose = &sxcav.Point{X: float32(route[i][0]), Y: float32(route[i][1])}
				path.Path[i] = pP
			}
			publishPath(path)
		}
	}
}

func main() {
	flag.Parse()
	var objects [][2]float64
	var err error
	var wg sync.WaitGroup

	feature = loadFeature(*jsonfile)

	objects, err = astar.ObjectsFromImage(feature.PGMFile, 200, 0, 0, 1)
	if err != nil || objects == nil {
		log.Fatal("Can't open map %v", err)
	}
	objectRadius := 1.0   //passable size 1.0m
	gridResolution := 1.0 //

	aStar = astar.NewAstar(objects, objectRadius, gridResolution)

	// start Synerex Provider
	go sxutil.HandleSigInt()
	sxutil.RegisterDeferFunction(sxutil.UnRegisterNode)
	log.Printf("PGM Routing Provider(%s) built %s sha1 %s", sxutil.GitVer, sxutil.BuildTime, sxutil.Sha1Ver)

	channels := []uint32{sxproto.ROUTING_SERVICE}

	var rerr error
	sxServerAddress, rerr = sxutil.RegisterNode(*nodesrv, "PGMRoute", channels, nil)
	if rerr != nil {
		log.Fatal("Can't register node:", rerr)
	}
	if *localsx != "" { // quick hack for AWS local network
		sxServerAddress = *localsx
	}
	log.Printf("Connecting SynerexServer at [%s]", sxServerAddress)

	client := sxutil.GrpcConnectServer(sxServerAddress)
	if client == nil {
		log.Fatal("Can't connect Synerex Server")
	} else {
		log.Print("Connecting SynerexServer")
	}
	sxClient = sxutil.NewSXServiceClient(client, sxproto.ROUTING_SERVICE, "{Client:PGMRoute}")

	ctx := context.Background()

	log.Print("Subscribe Routing Demand")
	sxClient.SubscribeDemand(ctx, demandCallback)

	wg.Add(1)
	wg.Wait()
}
